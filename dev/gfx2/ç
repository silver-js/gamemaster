// DOM setup
let res = 1;
const canv = document.getElementById('gm-main');
//const ctx = canv.getContext('2d');
const ctx = canv.getContext('2d', {alpha:false});
const checkFlip = ()=>{
  const r = window.innerWidth / window.innerHeight;
  canv.style = `
    box-shadow: 0 0 1px 1px grey;
    width: ${r < 1.79 ? '99%' : 'auto'};
    height: ${r < 1.79 ? 'auto' : window.innerHeight * .99 + 'px'};
    display: block;
    margin: 0 auto;
    image-rendering: pixelated;
  `;
}
checkFlip();
window.addEventListener("resize", checkFlip);
const reRes = ()=>{
  canv.width = 640 * res;
  canv.height = 360 * res;
}
reRes();


// internal values:
const deg = Math.PI/180;


// layers:

const spriteLayer = ()=>{
  const sCanv = document.createElement('canvas');
  sCanv.width = 640 * res;
  sCanv.height = 360 * res;
  sCanv.style = 'image-rendering: pixelated';
  const gl = sCanv.getContext('webgl2');
  gl.imageSmoothingEnabled = false;
  gl.webkitImageSmoothingEnabled = false;
  gl.mozImageSmoothingEnabled = false;
  /* ---------- TESTING ----------- */

  gl.clearColor(0.2,.2,.2,1.0);
  
  const modelData = new Float32Array([
    -.5, -.5,
    -.5, .5,
    .5, .5,
    .5, .5,
    .5, -.5,
    -.5, -.5
  ]);

  const modelBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, modelBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, modelData, gl.STATIC_DRAW);

  const spriteBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, spriteBuffer);

  const vertexTxt = `#version 300 es
    precision mediump float;
    
    layout(location = 0) in vec2 vertPos;

    layout(location = 1) in vec2 spritePos;
    layout(location = 2) in vec2 sprSize;
    layout(location = 3) in vec2 spin;
    layout(location = 4) in vec2 scale;
    layout(location = 5) in float type;
    layout(location = 6) in vec4 data;
    
    const float rad = 0.01745329;

    uniform vec2 pxScale;
    
    out vec3 texCoords;
    void main(){
      if(type == 0.0)
      {
        texCoords = vec3(vertPos, 1.0);
      }
      else if(type == 1.0)
      {
        texCoords = vec3(0.0, 0.0, 1.0);
      }
      else if(type == 2.0){
        texCoords = vec3(0.0, 1.0, 1.0);
      }
      else{
        texCoords = vec3(1.0, 0.0, 0.0);
      }
      gl_Position = vec4(vec2(
        vertPos * sprSize * vec2(cos(spin.x * rad), cos(spin.y * rad)) + vec2(-vertPos.y * sprSize.y * sin(spin.y * rad), vertPos.x * sprSize.x * sin(spin.x * rad)* scaleY) + spritePos
      ) * pxScale, 0.0, 1.0);
    }
  `;
  /*
      gl_Position = vec4(
        (
          vec2(
              vertPos.x * sprSize.x * cos(spin.x * rad) - vertPos.y * sprSize.y * sin(spin.y * rad) * scale.x,
              (vertPos.x * sprSize.x * sin(spin.x * rad) + vertPos.y * sprSize.y * cos(spin.y * rad)
          ) + vec2(spritePos)
        ) * pxScale, 0.0, 1.0
      );
  */
  const fragmentTxt = `#version 300 es
    precision mediump float;
    
    in vec3 texCoords;
    out vec4 outputColor;

    void main(){
      outputColor = vec4(texCoords.x * 16.0, texCoords.y * 16.0, 1.0,1.0);
    }
  `;
  
  const vShader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vShader, vertexTxt);
  gl.compileShader(vShader);

  const fShader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fShader, fragmentTxt);
  gl.compileShader(fShader);

  const triangleProgram = gl.createProgram();
  gl.attachShader(triangleProgram, vShader);
  gl.attachShader(triangleProgram, fShader);
  gl.linkProgram(triangleProgram);
  if(!gl.getProgramParameter(triangleProgram, gl.LINK_STATUS)){
    console.log(gl.getShaderInfoLog(vShader))
    console.log(gl.getShaderInfoLog(fShader))
  }
  gl.useProgram(triangleProgram);
  
  // attribs
  gl.enableVertexAttribArray(0);
  gl.enableVertexAttribArray(1);
  gl.enableVertexAttribArray(2);
  gl.enableVertexAttribArray(3);
  gl.enableVertexAttribArray(4);
  gl.enableVertexAttribArray(5);
  gl.vertexAttribDivisor(1,1);
  gl.vertexAttribDivisor(2,1);
  gl.vertexAttribDivisor(3,1);
  gl.vertexAttribDivisor(4,1);
  gl.vertexAttribDivisor(5,1);
  
  // uniforms
  const pxScaleLocation = gl.getUniformLocation(triangleProgram, 'pxScale');
  
  gl.uniform2f(pxScaleLocation, 2 / 640, 2 / 360);


  // attrib pointers:
  gl.bindBuffer(gl.ARRAY_BUFFER, modelBuffer);
  gl.vertexAttribPointer(
    0,        // index
    2,        // size
    gl.FLOAT, // type
    false,    // normalization
    2 * 4,    // data size in bytes
    0         // attrib offset in bytes
  );
  
  gl.bindBuffer(gl.ARRAY_BUFFER, spriteBuffer);
  gl.vertexAttribPointer(
    1,
    2,
    gl.FLOAT,
    false,
    13 * 4,
    0
  );
  gl.vertexAttribPointer(
    2,
    2,
    gl.FLOAT,
    false,
    13 * 4,
    2 * 4
  );
  gl.vertexAttribPointer(
    3,
    2,
    gl.FLOAT,
    false,
    13 * 4,
    4 * 4
  );
  gl.vertexAttribPointer(
    4,
    2,
    gl.FLOAT,
    false,
    13 * 4,
    6 * 4
  );
  gl.vertexAttribPointer(
    5,
    1,
    gl.FLOAT,
    false,
    13 * 4,
    8 * 4
  );
  gl.vertexAttribPointer(
    6,
    4,
    gl.FLOAT,
    false,
    13 * 4,
    9 * 4
  );
  let spriteArr = [];
  
  const drawSprites = (arr)=>{
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(arr), gl.STATIC_DRAW);

    gl.drawArraysInstanced(gl.TRIANGLES, 0, 6, Math.floor(arr.length / 6));
    ctx.drawImage(sCanv,0,0);
  }

  /* ---------- TESTING ----------- */
  
  return {
    spr: (aId, iId, x, y, w = 32, h = 32, sX = 0, sY, scaleX = 1, scaleY = 1)=>{
      spriteArr.push(x, y, w, h, sX, sY != undefined ? sY : sX, scaleX, scaleY, 2, aId, iId, 0, 0);
    },
    draw: ()=>{
      drawSprites(spriteArr)
      spriteArr = [];
    },
    setAtlas: ()=>{}
  }
}


// sprites loader

const loadAtlas = async(url, res, scale = 1, ox = 0, oy = 0, hGap = 0, vGap = 0)=>{
  const aImg = new Image();
  aImg.src = url;
  await aImg.decode();

  const cSize = res * scale;

  const aCanv = document.createElement('canvas');
  aCanv.width = cSize;
  aCanv.height = cSize;
  const aCtx = aCanv.getContext('2d');
  aCtx.imageSmoothingEnabled = false;
  aCtx.webkitImageSmoothingEnabled = false;
  aCtx.mozImageSmoothingEnabled = false;

  const imgArr = [];
  const saveImg = ()=>{
    const nImg = new Image();
    nImg.src = aCanv.toDataURL('image/png');
    imgArr.push(nImg)
  }
  saveImg();
  for(let vIndex=oy; vIndex<aImg.height; vIndex+=res+vGap){
    for(let hIndex=ox; hIndex<aImg.width; hIndex+=res+hGap){
      aCtx.drawImage(
        aImg,
        hIndex, vIndex, res, res,
        0, 0, cSize, cSize
      );
      saveImg();
    }
  }
  return imgArr;
}


// shader buffer

const sBuffer = ()=>{
  const bCanv = document.createElement('canvas');
  bCanv.width = 640;
  bCanv.height = 360;
  const bGl = bCanv.getContext('webgl');

  const vBuffer = bGl.createBuffer();
  bGl.bindBuffer(bGl.ARRAY_BUFFER, vBuffer);
  
  return {
    vShader: async (vsTxt)=>{
      try{
        const vRes = await fetch(vsTxt);
        if(vRes.ok){
          const vData = await vRes.text();
          const vShader = bGl.createShader(bGl.VERTEX_SHADER);
          bGl.shaderSource(vShader, vData);
          bGl.compileShader(vShader);
          return vShader;
        }else{
          console.log('failed to fetch vertex shader');
        }
      }
      catch(err){
        console.log('error: ', err);
      }
      return false;
    },
    fShader: async (fsTxt)=>{
      try{
        const fRes = await fetch(fsTxt);
        if(fRes.ok){
          const fData = await fRes.text();
          const fShader = bGl.createShader(bGl.FRAGMENT_SHADER);
          bGl.shaderSource(fShader, fData);
          bGl.compileShader(fShader);
          return fShader;
        }else{
          console.log('failed to fetch fragment shader');
        }
      }
      catch(err){
        console.log('error: ', err);
      }
      return false;
    },
    newProgram: (vShader,fShader)=>{
      const program = bGl.createProgram();
      bGl.attachShader(program,vShader);
      bGl.attachShader(program,fShader);
      bGl.linkProgram(program);
    },
    useProgram: (p)=>{
      bGl.useProgram(p);
    },
    vertexBuffer: (data)=>{
      bGl.bufferData(bGl.ARRAY_BUFFER, data, bGl.STATIC_DRAW);
    }
  }
}


// main canvas methods

const clear = ()=> ctx.clearRect(0,0,640,360);


// export

export default {spriteLayer, sBuffer, clear, loadAtlas};


/*
to test...

  bCtx.filter = 'url(data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg"><filter id="f" color-interpolation-filters="sRGB"><feComponentTransfer><feFuncA type="discrete" tableValues="0 1"/></feComponentTransfer></filter></svg>#f)';

*/
