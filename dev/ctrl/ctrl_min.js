function e(){this.axis=new Float32Array(4),this.btn=new Uint8ClampedArray(8)}export const _pad=[];for(let t=0;t<5;t++)_pad.push(new e);const t=[];let n,o=!1;const s=new Float32Array(2),a=e=>e.preventDefault(),d=e=>{_pad[0].btn[e.button]=255},i=e=>{e.preventDefault(),e.deltaY>=0?(_pad[0].btn[4]=255,t.push([0,4])):(_pad[0].btn[5]=255,t.push([0,5]))},c=e=>{if(document.pointerLockElement)return s[0]+=e.movementX/n.offsetWidth*2,s[1]+=e.movementY/n.offsetWidth*2,void _pad[0].axis.set([s[0],s[1]],2);o||_pad[0].axis.set([e.offsetX/n.offsetWidth*2-1,e.offsetY/n.offsetHeight*2-1],2)},r=e=>{_pad[0].axis[2]*=1.2,_pad[0].axis[3]*=1.2};let p;const l=()=>{n.requestPointerLock()},m=new Float32Array(4),f=e=>(e.changedTouches[0].pageX-n.offsetLeft)/n.offsetWidth*2-1,u=e=>(e.changedTouches[0].pageY-n.offsetTop)/n.offsetHeight*2-1,v=[],h={};let b=1;const x=e=>{e.cancelable&&e.preventDefault(),b=n.offsetHeight/n.offsetWidth;const t=f(e),s=u(e);((e,t,n)=>{const o=v.find((n=>!(n.x>e||n.x+n.w<e||n.y>t||n.y+n.h<t)));o&&(h[n]=o)})(t,s,e.changedTouches[0].identifier);const a=h[e.changedTouches[0].identifier];if(a)switch(a.t){case"btn":_pad[0].btn[a.m]=255;break;case"stick":a.oX=t,a.oY=s,_pad[0].axis[a.m[0]]=0,_pad[0].axis[a.m[1]]=0;break;case"swipe":a.oX=t,a.oY=s}else _pad[0].btn[3]=255,o?m.set([t,s,t,s]):_pad[0].axis.set([t,s],2)},_=e=>{e.preventDefault();const t=h[e.changedTouches[0].identifier];if(t)switch(t.t){case"stick":_pad[0].axis[t.m[0]]=5*Math.max(-.2,Math.min(f(e)-t.oX,.2)),_pad[0].axis[t.m[1]]=5*Math.max(-.2,Math.min((u(e)-t.oY)*b,.2));break;case"swipe":_pad[0].btn[t.m[0]]=(u(e)-t.oY)*b>.1?255:0,_pad[0].btn[t.m[1]]=f(e)-t.oX>.1?255:0,_pad[0].btn[t.m[2]]=f(e)-t.oX<-.1?255:0,_pad[0].btn[t.m[3]]=(u(e)-t.oY)*b<-.1?255:0}else{if(o)return _pad[0].axis.set([2*(f(e)-m[0]),2*(u(e)-m[1])],2),void m.set([f(e),u(e)],2);_pad[0].axis.set([f(e),u(e)],2)}},L=e=>{e.cancelable&&e.preventDefault(),m.set([0,0]);const n=h[e.changedTouches[0].identifier];if(n){switch(n.t){case"btn":_pad[0].btn[n.m]=0;break;case"stick":_pad[0].axis[n.m[0]]=0,_pad[0].axis[n.m[1]]=0;break;case"swipe":_pad[0].btn[n.m[0]]=0,_pad[0].btn[n.m[1]]=0,_pad[0].btn[n.m[2]]=0,_pad[0].btn[n.m[3]]=0}return n.c>=0&&f(e)==n.oX&&u(e)==n.oY&&(_pad[0].btn[n.c]=255,t.push([0,n.c])),void delete h[e.changedTouches[0].identifier]}_pad[0].btn[3]=0};let w=!0;const E=[],g={KeyW:[1,"axis",1,!0],KeyA:[1,"axis",0,!0],KeyS:[1,"axis",1],KeyD:[1,"axis",0],KeyN:[1,"btn",0],KeyM:[1,"btn",1],Space:[1,"btn",2],AltLeft:[1,"btn",3],KeyQ:[1,"btn",4],KeyE:[1,"btn",5],Tab:[1,"btn",6],Enter:[1,"btn",7]},k={F10:()=>w=!w},y=[null,null,null,null];let Y=0;const T=e=>{if(y.findIndex((e=>null==e))>=0){for(;null!=y[Y];)Y=(Y+1)%4;y[Y]=e,console.log(`connected to slot ${Y+1}`),Y=(Y+1)%4}else console.log("no more gamepad slots available")},X=e=>{const t=y.findIndex((t=>t==e));t>=0&&(y[t]=null)};let D=0;const K=()=>{document.pointerLockElement?(n.removeEventListener("mousewheel",i),window.addEventListener("mousewheel",i,{passive:!1})):(n.addEventListener("mousewheel",i),window.removeEventListener("mousewheel",i))};window.addEventListener("mouseup",(e=>{_pad[0].btn[e.button]=0})),document.addEventListener("pointerlockchange",K),window.addEventListener("keydown",(e=>{if(k[e.code])return e.preventDefault(),void k[e.code]();w&&e.preventDefault(),E.find((t=>t==e.code))||E.unshift(e.code)})),window.addEventListener("keyup",(e=>{const t=E.findIndex((t=>t==e.code));if(t>=0){e.preventDefault(),E.splice(t,1);const n=g[e.code];n&&(_pad[n[0]][n[1]][n[2]]=0)}})),window.addEventListener("gamepadconnected",(e=>{console.log(e.gamepad.buttons[0]),console.log(`${e.gamepad.id} detected.`),T(e.gamepad.index)})),window.addEventListener("gamepaddisconnected",(e=>{X((t=>t==e.gamepad.index)),console.log(`${e.gamepad.id} disconnected.`,y)}));export const _padUpdate=()=>{(()=>{for(const e of navigator.getGamepads())if(e){e.buttons[8].pressed&&e.buttons[9].pressed&&D<performance.now()&&(X(e.index),T(e.index),D=performance.now()+250);const t=y.findIndex((t=>t==e.index));if(t>=0){for(let n=0;n<4;n++)_pad[t+1].axis[n]=e.axes[n];for(let n=0;n<6;n++)_pad[t+1].btn[n]=e.buttons[n].pressed?255:0;for(let n=8;n<10;n++)_pad[t+1].btn[n-2]=e.buttons[n].pressed?255:0}}})(),(e=>{let t;for(let e=E.length-1;e>=0;e--)if(t=g[E[e]],t)switch(t[1]){case"btn":_pad[t[0]].btn[t[2]]=255;break;case"axis":_pad[t[0]].axis[t[2]]=t[3]?-1:1}})(),(()=>{for(let e=t.length;e>0;e--){const e=t.pop();_pad[e[0]].btn[e[1]]=0}o&&(s.set([0,0]),m.set([m[2],m[3]]),_pad[0].axis.set([0,0],2))})()};export const _padCfg={pointerTarget:e=>{(e=>{n&&(n.removeEventListener("mousewheel",i),n.removeEventListener("mouseleave",r),n.removeEventListener("mousemove",c),n.removeEventListener("contextmenu",a),n.removeEventListener("mousedown",d),n.removeEventListener("touchstart",x),n.removeEventListener("touchmove",_),n.removeEventListener("touchend",L),n.removeEventListener("touchcancel",L)),n=e,K(),e.addEventListener("mouseleave",r),e.addEventListener("mousemove",c),e.addEventListener("contextmenu",a),e.addEventListener("mousedown",d),e.addEventListener("touchstart",x),e.addEventListener("touchmove",_),e.addEventListener("touchend",L),e.addEventListener("touchcancel",L)})(e)},pointerLock:e=>{o=!!e,e?(p&&p.removeEventListener("click",l),p=n,n.addEventListener("click",l),console.log("pointerLock on")):(p&&p.removeEventListener("click",l),document.exitPointerLock(),console.log("pointerLock off"))},tpAdd:(e,t,n,o,s,a,d)=>{v.push({x:e,y:t,w:n,h:o,t:s,m:a,c:d,oX:0,oY:0})},tpRemove:(e,t)=>{const n=v.findIndex((n=>n.x===e&&n.y===t));n>=0&&v.splice(n,1)},getKbMap:()=>g,kbAdd:(...e)=>{e.forEach((e=>{g[e.key]=e.map}))},kbRemove:(...e)=>{e.forEach((e=>{delete g[e]}))}};
